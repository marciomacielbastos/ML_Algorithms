# -*- coding: utf-8 -*-
"""Implementação SOM + KPI.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1CrnRuhrdrpC7k8ADGYuOaT7XY-EwENTz
"""

import numpy as np
from matplotlib import pyplot as plt
import numpy as np
from sklearn.datasets import fetch_olivetti_faces

class SOM:
    def __init__(self, W, eta0=1, sigma0=3, tau=100, iterations=5000, burnin=500):
        self.eta0 = eta0
        self.sigma0 = sigma0
        self.tau = tau
        self.W = W
        self.distances = self.calc_distance_matrix()
        self.p_train = np.zeros(W.shape[0] * W.shape[1])
        self.iterations = iterations
        self.burnin = burnin

    def unscaled_eta(self, t):
        return np.exp(-t / self.tau)

    def eta(self, t):
        if t - 1 < self.burnin:
            return self.eta0 * self.unscaled_eta(t)
        else:
            return 0.2 * self.eta0

    def sigma(self, t):
        if t - 1 < self.burnin:
            return self.sigma0 * self.unscaled_eta(t)
        else:
            return self.sigma0 / 3

    def line_to_plane(self, idx):
        return (idx // self.W.shape[1], idx % self.W.shape[1])

    def calc_distance(self, v, w):
        axis = (len(v.shape) - 1)
        return np.linalg.norm(v - w, ord=2, axis=axis)

    def winning_unit(self, x):
        distances = self.calc_distance(self.W, x)
        closer_unit = np.argmin(distances)
        return closer_unit

    def calc_distance_matrix(self):
        dim = self.W.shape[0] * self.W.shape[1]
        distances = np.zeros((dim, dim))
        for i in range(dim):
            for j in range(i + 1,dim):
                v = np.array(self.line_to_plane(i))
                w = np.array(self.line_to_plane(j))
                distances[i, j] = self.calc_distance (v, w)
                distances[j, i] = self.calc_distance (v, w)
        return distances

    def calc_distance_factor(self, u, t):
        d = 2.0 * np.power(self.sigma(t), 2)
        distance_factor = np.exp(-self.distances[u] / d)
        distance_factor = distance_factor.reshape(W.shape[0], W.shape[1])
        distance_factor = np.expand_dims(distance_factor, axis=2)
        return distance_factor

    def calc_dW(self, t, x):
        u = self.winning_unit(x)
        self.p_train[u] += 1
        distance_factor = self.calc_distance_factor(u, t)
        dW = self.eta(t) * np.multiply(distance_factor, (x - W))
        return dW

    def fit(self, X):
        sequence = np.arange(X.shape[0])
        for i in range(self.iterations):
            print ("\r["+"="*int(70 * i/self.iterations)+" "*int(70 * (1 - i/self.iterations))+"][{:.1f} %]".format(i/self.iterations * 100.), end="")
            for n in sequence:
                x = X[n]
                dW = self.calc_dW(i + 1, x)
                self.W += dW
                self.W /= np.linalg.norm(self.W, axis=2).reshape((self.W.shape[0], self.W.shape[1], 1))
        self.p_train /= (X.shape[0] * self.iterations)
        return self.W

    def predict(self, x):
        return self.winning_unit(x)

    def get_pTrain(self):
        return self.p_train

faces = fetch_olivetti_faces(shuffle=True)
Xcomplete = faces['data'].astype(np.float64) / np.max(faces['data'])
np.random.shuffle(Xcomplete)
X_train = Xcomplete[0:100]

XD = []
init = 100
Nd = 10
D = 30
for i in range(D):
    XD.append(Xcomplete[init:init + Nd])
    init += 10

pattern_length = 64 * 64
matrix_side = 5
W = np.random.normal(0, 0.1, size=(matrix_side, matrix_side, pattern_length))

som = SOM(W=W)
W = som.fit(X_train)

w=10
h=10
fig=plt.figure(figsize=(8, 8))
columns = 5
rows = 5
for i in range(0, columns*rows):
    img = W[i // 5, i % 5].reshape(64, 64)
    fig.add_subplot(rows, columns, i + 1)
    plt.imshow(img)
plt.show()

pD = []
for X in XD:
    pd = [0] * (W.shape[0] * W.shape[1])
    for x in X:
        u = som.predict(x)
        pd[u] += 1
    pD.append(np.array(pd) / Nd)

pTrain = som.get_pTrain()
KPI = []
for d in range(D):
    KPI_d = 0
    for i in range(W.shape[0] * W.shape[1]):
        KPI_d += pD[d][i] * (1 - np.abs(pTrain[i] - pD[d][i])) / (1 + np.abs(pTrain[i] - pD[d][i]))
    KPI.append(KPI_d)

KPI

KPI = np.array(KPI)
mu = KPI.mean()
std = KPI.std()

thr1 = mu - (3 * std)
thr2 = mu - (5 * std)

KPI[KPI < thr1]

KPI[KPI < thr2]